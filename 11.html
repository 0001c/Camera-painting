<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éš”ç©ºå†™å­— - é›ªèŠ±é£˜è½ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft Yahei', sans-serif;
        }

        body {
            background: #000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #video-container {
            position: relative;
            flex: 1;
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ï¼Œæ›´ç¬¦åˆç›´è§‰ */
            opacity: 0.3; /* åŠé€æ˜æ˜¾ç¤ºè§†é¢‘ */
            z-index: 1;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            cursor: none;
        }

        #snow-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }

        /* åŠŸèƒ½é¢æ¿æ ·å¼ */
        #control-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 20px;
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            z-index: 10;
            box-shadow: 0 0 20px rgba(0, 0, 255, 0.3);
        }

        .control-item {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 3px solid transparent;
        }

        .control-item:hover, .control-item.active {
            transform: scale(1.1);
            border-color: #0078ff;
        }

        .pen {
            background: #f0f0f0;
            font-size: 24px;
        }

        .eraser {
            background: #f0f0f0;
            font-size: 24px;
        }

        .color-red {
            background: red;
        }

        .color-green {
            background: green;
        }

        .color-blue {
            background: blue;
        }

        .size-small {
            background: #ccc;
            font-size: 12px;
        }

        .size-medium {
            background: #ccc;
            font-size: 18px;
        }

        .size-large {
            background: #ccc;
            font-size: 24px;
        }

        /* æç¤ºæ–‡æœ¬ */
        #hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            text-align: center;
            z-index: 5;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
        }

        /* åŠ è½½æç¤º */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <div id="loading">æ­£åœ¨åŠ è½½æ‰‹éƒ¨æ£€æµ‹æ¨¡å‹ï¼Œè¯·ç¨å€™...</div>
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        <canvas id="snow-canvas"></canvas>
        
        <!-- æ§åˆ¶é¢æ¿ -->
        <div id="control-panel">
            <div class="control-item pen active" data-type="tool" data-value="pen">âœï¸</div>
            <div class="control-item eraser" data-type="tool" data-value="eraser">ğŸ§½</div>
            <div class="control-item" data-type="clear">ğŸ—‘ï¸</div>
            
            <div class="control-item color-red" data-type="color" data-value="#ff0000"></div>
            <div class="control-item color-green" data-type="color" data-value="#00ff00"></div>
            <div class="control-item color-blue" data-type="color" data-value="#0000ff"></div>
            
            <div class="control-item size-small" data-type="size" data-value="5">å°</div>
            <div class="control-item size-medium" data-type="size" data-value="10">ä¸­</div>
            <div class="control-item size-large" data-type="size" data-value="15">å¤§</div>
        </div>
        
        <div id="hint">
            ğŸ–ï¸ ä¼¸å‡ºæ‰‹æŒæ˜¾ç¤ºæ§åˆ¶é¢æ¿ | ğŸ¤ æ‹‡æŒ‡é£ŸæŒ‡ç›¸è§¦å¼€å§‹å†™å­— | 
            âœŒï¸ é£ŸæŒ‡ä¸­æŒ‡å¼ å¼€æ¸…é™¤æ–‡å­— | ğŸ–Œï¸ åŒæŒ‡ç¼©æ”¾æ–‡å­—
        </div>
    </div>

    <!-- MediaPipe åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1646425289/camera_utils.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1646424915/drawing_utils.min.js"></script>

    <script>
        // å…¨å±€å˜é‡
        let video, canvas, snowCanvas, ctx, snowCtx;
        let hands = null;
        let isModelLoaded = false;
        let controlPanel, loading;
        
        // ç»˜ç”»çŠ¶æ€
        let drawingState = {
            tool: 'pen',          // å½“å‰å·¥å…·ï¼špen/eraser
            color: '#ff0000',     // ç”»ç¬”é¢œè‰²
            size: 10,             // ç”»ç¬”å¤§å°
            isDrawing: false,     // æ˜¯å¦æ­£åœ¨ç»˜ç”»
            lastPosition: null,   // ä¸Šä¸€å¸§æ‰‹æŒ‡ä½ç½®
            points: [],           // æ‰€æœ‰ç»˜ç”»ç‚¹
            scalePoints: [],      // ç¼©æ”¾æ§åˆ¶ç‚¹
            snowflakes: [],       // é›ªèŠ±ç²’å­
            panelVisible: false,  // æ§åˆ¶é¢æ¿æ˜¯å¦æ˜¾ç¤º
            selectedItem: null    // å½“å‰é€‰ä¸­çš„é¢æ¿é¡¹
        };

        // åˆå§‹åŒ–
        async function init() {
            // è·å–DOMå…ƒç´ 
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            snowCanvas = document.getElementById('snow-canvas');
            controlPanel = document.getElementById('control-panel');
            loading = document.getElementById('loading');
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            ctx = canvas.getContext('2d');
            snowCtx = snowCanvas.getContext('2d');

            // åˆå§‹åŒ–MediaPipe Hands
            await initMediaPipeHands();
            
            // å¯åŠ¨æ‘„åƒå¤´
            await startCamera();
            
            // éšè—åŠ è½½æç¤º
            loading.style.display = 'none';
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            requestAnimationFrame(animate);
        }

        // è°ƒæ•´ç”»å¸ƒå°ºå¯¸
        function resizeCanvas() {
            const container = document.getElementById('video-container');
            const { width, height } = container.getBoundingClientRect();
            
            canvas.width = width;
            canvas.height = height;
            snowCanvas.width = width;
            snowCanvas.height = height;
        }

        // åˆå§‹åŒ–MediaPipe Hands
        async function initMediaPipeHands() {
            hands = new window.mediapipe.Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
            });

            // é…ç½®å‚æ•°
            hands.setOptions({
                maxNumHands: 2,          // æœ€å¤šæ£€æµ‹2åªæ‰‹
                modelComplexity: 1,      // æ¨¡å‹å¤æ‚åº¦
                minDetectionConfidence: 0.7, // æ£€æµ‹ç½®ä¿¡åº¦
                minTrackingConfidence: 0.7   // è·Ÿè¸ªç½®ä¿¡åº¦
            });

            // å¤„ç†æ£€æµ‹ç»“æœ
            hands.onResults(handleResults);

            isModelLoaded = true;
        }

        // å¯åŠ¨æ‘„åƒå¤´
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user', // å‰ç½®æ‘„åƒå¤´
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                
                // ç­‰å¾…è§†é¢‘åŠ è½½
                await new Promise(resolve => {
                    video.onloadedmetadata = resolve;
                });
                
            } catch (err) {
                console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', err);
                alert('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™å¹¶å¯ç”¨æ‘„åƒå¤´');
            }
        }

        // å¤„ç†æ‰‹éƒ¨æ£€æµ‹ç»“æœ
        function handleResults(results) {
            if (!results.multiHandLandmarks) {
                // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œé‡ç½®çŠ¶æ€
                drawingState.isDrawing = false;
                drawingState.lastPosition = null;
                drawingState.scalePoints = [];
                return;
            }

            // è·å–æ‰€æœ‰æ£€æµ‹åˆ°çš„æ‰‹
            const hands = results.multiHandLandmarks;
            
            // æ¸…ç©ºç”»å¸ƒï¼ˆä¿ç•™ç»˜åˆ¶å†…å®¹ï¼‰
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
            
            // é•œåƒç¿»è½¬ç”»å¸ƒä»¥åŒ¹é…è§†é¢‘
            ctx.scale(-1, 1);
            ctx.translate(-canvas.width, 0);

            // å¤„ç†æ¯åªæ‰‹
            hands.forEach((hand, handIndex) => {
                processHand(hand, handIndex, hands.length);
            });

            // ç»˜åˆ¶æ‰€æœ‰ä¿ç•™çš„ç‚¹
            drawAllPoints();
            
            // æ¢å¤ç”»å¸ƒçŠ¶æ€
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // å¤„ç†å•åªæ‰‹çš„å…³é”®ç‚¹
        function processHand(hand, handIndex, totalHands) {
            // è·å–å…³é”®ç‚¹åæ ‡
            const landmarks = hand;
            
            // å…³é”®èŠ‚ç‚¹ç´¢å¼•ï¼šhttps://developers.google.com/mediapipe/solutions/vision/hand_landmarker
            const thumbTip = landmarks[4];    // æ‹‡æŒ‡æŒ‡å°–
            const indexTip = landmarks[8];    // é£ŸæŒ‡æŒ‡å°–
            const middleTip = landmarks[12];  // ä¸­æŒ‡æŒ‡å°–
            const wrist = landmarks[0];       // æ‰‹è…•

            // è½¬æ¢ä¸ºç”»å¸ƒåæ ‡
            const convert = (point) => ({
                x: point.x * canvas.width,
                y: point.y * canvas.height
            });

            const thumb = convert(thumbTip);
            const index = convert(indexTip);
            const middle = convert(middleTip);
            const wristPos = convert(wrist);

            // è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»
            const getDistance = (p1, p2) => {
                return Math.hypot(p1.x - p2.x, p1.y - p2.y);
            };

            // 1. æ£€æµ‹æ‰‹æŒå¼ å¼€ï¼ˆæ˜¾ç¤ºæ§åˆ¶é¢æ¿ï¼‰
            const palmOpen = isPalmOpen(landmarks);
            if (palmOpen) {
                if (!drawingState.panelVisible) {
                    drawingState.panelVisible = true;
                    controlPanel.style.display = 'grid';
                    // é‡ç½®é€‰ä¸­é¡¹
                    drawingState.selectedItem = null;
                }
                
                // ç”¨é£ŸæŒ‡é€‰æ‹©é¢æ¿é¡¹
                selectPanelItem(index);
            } else if (drawingState.panelVisible) {
                // æ‰‹æŒé—­åˆï¼Œéšè—é¢æ¿
                drawingState.panelVisible = false;
                controlPanel.style.display = 'none';
                
                // åº”ç”¨é€‰ä¸­çš„è®¾ç½®
                if (drawingState.selectedItem) {
                    applyPanelSelection(drawingState.selectedItem);
                }
            }

            // 2. æ£€æµ‹æ‹‡æŒ‡å’Œé£ŸæŒ‡ç›¸è§¦ï¼ˆå¼€å§‹å†™å­—ï¼‰
            const thumbIndexDistance = getDistance(thumb, index);
            const isPinch = thumbIndexDistance < 30; // è·ç¦»é˜ˆå€¼

            if (isPinch && !drawingState.panelVisible) {
                if (!drawingState.isDrawing) {
                    drawingState.isDrawing = true;
                    drawingState.lastPosition = index;
                } else {
                    // ç»˜åˆ¶çº¿æ¡
                    if (drawingState.lastPosition) {
                        ctx.beginPath();
                        ctx.moveTo(drawingState.lastPosition.x, drawingState.lastPosition.y);
                        ctx.lineTo(index.x, index.y);
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        if (drawingState.tool === 'pen') {
                            ctx.strokeStyle = drawingState.color;
                            ctx.lineWidth = drawingState.size;
                            ctx.stroke();
                            
                            // ä¿å­˜ç»˜åˆ¶ç‚¹
                            drawingState.points.push({
                                x: index.x,
                                y: index.y,
                                color: drawingState.color,
                                size: drawingState.size,
                                path: [drawingState.lastPosition, index]
                            });
                        } else if (drawingState.tool === 'eraser') {
                            // æ©¡çš®æ“¦åŠŸèƒ½
                            erasePoints(index, drawingState.size * 2);
                        }
                    }
                    drawingState.lastPosition = index;
                }
            } else {
                drawingState.isDrawing = false;
                drawingState.lastPosition = null;
            }

            // 3. æ£€æµ‹åŒæŒ‡ç¼©æ”¾ï¼ˆä¸¤åªæ‰‹çš„é£ŸæŒ‡ï¼‰
            if (totalHands === 2 && handIndex === 0) {
                const otherHand = hands[1];
                const otherIndex = convert(otherHand[8]);
                drawingState.scalePoints = [index, otherIndex];
                
                // è®¡ç®—ç¼©æ”¾ä¸­å¿ƒå’Œè·ç¦»
                const center = {
                    x: (index.x + otherIndex.x) / 2,
                    y: (index.y + otherIndex.y) / 2
                };
                const distance = getDistance(index, otherIndex);
                
                // åº”ç”¨ç¼©æ”¾
                scaleDrawing(center, distance);
            }

            // 4. æ£€æµ‹é£ŸæŒ‡å’Œä¸­æŒ‡å¼ å¼€ï¼ˆæ¸…é™¤æ–‡å­—ï¼Œè½¬ä¸ºé›ªèŠ±ï¼‰
            const indexMiddleDistance = getDistance(index, middle);
            const isTwoFingersOpen = indexMiddleDistance > 80;
            
            if (isTwoFingersOpen && !drawingState.panelVisible && drawingState.points.length > 0) {
                // å°†ç»˜åˆ¶ç‚¹è½¬ä¸ºé›ªèŠ±
                convertToSnowflakes();
                drawingState.points = [];
            }

            // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹ï¼ˆè°ƒè¯•ç”¨ï¼‰
            drawHandLandmarks(landmarks);
        }

        // åˆ¤æ–­æ‰‹æŒæ˜¯å¦å¼ å¼€
        function isPalmOpen(landmarks) {
            // æ£€æŸ¥ä¸»è¦æ‰‹æŒ‡æ˜¯å¦å¼ å¼€
            const fingerTips = [8, 12, 16, 20]; // é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡æŒ‡å°–
            const fingerMCP = [5, 9, 13, 17];   // æ‰‹æŒ‡æŒæŒ‡å…³èŠ‚
            
            let openCount = 0;
            for (let i = 0; i < fingerTips.length; i++) {
                const tip = landmarks[fingerTips[i]];
                const mcp = landmarks[fingerMCP[i]];
                
                // æŒ‡å°–åœ¨æŒæŒ‡å…³èŠ‚å¤–ä¾§è§†ä¸ºå¼ å¼€
                if (tip.y < mcp.y - 0.02) { // 0.02æ˜¯ç›¸å¯¹é˜ˆå€¼
                    openCount++;
                }
            }
            
            return openCount >= 3; // è‡³å°‘3æ ¹æ‰‹æŒ‡å¼ å¼€
        }

        // é€‰æ‹©é¢æ¿é¡¹
        function selectPanelItem(index) {
            const panelRect = controlPanel.getBoundingClientRect();
            // è½¬æ¢é£ŸæŒ‡åæ ‡åˆ°å±å¹•åæ ‡ç³»ï¼ˆå–æ¶ˆé•œåƒï¼‰
            const screenX = canvas.width - index.x;
            const screenY = index.y;

            // æ£€æŸ¥æ˜¯å¦åœ¨é¢æ¿èŒƒå›´å†…
            if (
                screenX >= panelRect.left && screenX <= panelRect.right &&
                screenY >= panelRect.top && screenY <= panelRect.bottom
            ) {
                // æ‰¾åˆ°è¢«é€‰ä¸­çš„é¡¹
                const items = controlPanel.querySelectorAll('.control-item');
                items.forEach(item => {
                    const rect = item.getBoundingClientRect();
                    if (
                        screenX >= rect.left && screenX <= rect.right &&
                        screenY >= rect.top && screenY <= rect.bottom
                    ) {
                        // é«˜äº®é€‰ä¸­é¡¹
                        items.forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                        drawingState.selectedItem = item;
                    }
                });
            }
        }

        // åº”ç”¨é¢æ¿é€‰æ‹©
        function applyPanelSelection(item) {
            const type = item.dataset.type;
            const value = item.dataset.value;
            
            switch (type) {
                case 'tool':
                    drawingState.tool = value;
                    break;
                case 'color':
                    drawingState.color = value;
                    break;
                case 'size':
                    drawingState.size = parseInt(value);
                    break;
                case 'clear':
                    drawingState.points = [];
                    drawingState.snowflakes = [];
                    break;
            }
        }

        // ç»˜åˆ¶æ‰€æœ‰ä¿ç•™çš„ç‚¹
        function drawAllPoints() {
            drawingState.points.forEach(point => {
                ctx.beginPath();
                ctx.moveTo(point.path[0].x, point.path[0].y);
                ctx.lineTo(point.path[1].x, point.path[1].y);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = point.color;
                ctx.lineWidth = point.size;
                ctx.stroke();
            });
        }

        // æ©¡çš®æ“¦åŠŸèƒ½
        function erasePoints(position, radius) {
            const newPoints = [];
            const { x, y } = position;
            
            drawingState.points.forEach(point => {
                // æ£€æŸ¥çº¿æ®µæ˜¯å¦ä¸æ©¡çš®æ“¦åœ†ç›¸äº¤
                const p1 = point.path[0];
                const p2 = point.path[1];
                
                const distance = distanceFromPointToLine(x, y, p1.x, p1.y, p2.x, p2.y);
                if (distance > radius) {
                    newPoints.push(point);
                }
            });
            
            drawingState.points = newPoints;
        }

        // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
        function distanceFromPointToLine(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return Math.hypot(A, B);
            
            let param = dot / lenSq;
            
            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            return Math.hypot(px - xx, py - yy);
        }

        // ç¼©æ”¾ç»˜åˆ¶å†…å®¹
        let lastScaleDistance = null;
        function scaleDrawing(center, distance) {
            if (!lastScaleDistance) {
                lastScaleDistance = distance;
                return;
            }
            
            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
            const scaleRatio = distance / lastScaleDistance;
            lastScaleDistance = distance;
            
            // åº”ç”¨ç¼©æ”¾åˆ°æ‰€æœ‰ç‚¹
            drawingState.points = drawingState.points.map(point => {
                return {
                    ...point,
                    x: center.x + (point.x - center.x) * scaleRatio,
                    y: center.y + (point.y - center.y) * scaleRatio,
                    size: point.size * scaleRatio,
                    path: point.path.map(p => ({
                        x: center.x + (p.x - center.x) * scaleRatio,
                        y: center.y + (p.y - center.y) * scaleRatio
                    }))
                };
            });
            
            // åº”ç”¨ç¼©æ”¾åˆ°é›ªèŠ±
            drawingState.snowflakes = drawingState.snowflakes.map(snow => {
                return {
                    ...snow,
                    x: center.x + (snow.x - center.x) * scaleRatio,
                    y: center.y + (snow.y - center.y) * scaleRatio,
                    size: snow.size * scaleRatio
                };
            });
        }

        // è½¬æ¢ç»˜åˆ¶ç‚¹ä¸ºé›ªèŠ±
        function convertToSnowflakes() {
            drawingState.points.forEach(point => {
                // ä¸ºæ¯ä¸ªçº¿æ®µåˆ›å»ºå¤šä¸ªé›ªèŠ±
                const p1 = point.path[0];
                const p2 = point.path[1];
                const segments = Math.floor(getDistance(p1, p2) / 10);
                
                for (let i = 0; i < segments; i++) {
                    const t = i / segments;
                    const x = p1.x + (p2.x - p1.x) * t;
                    const y = p1.y + (p2.y - p1.y) * t;
                    
                    drawingState.snowflakes.push({
                        x: x,
                        y: y,
                        size: point.size * (0.5 + Math.random() * 0.5),
                        color: point.color,
                        velocity: 1 + Math.random() * 3, // ä¸‹è½é€Ÿåº¦
                        drift: (Math.random() - 0.5) * 2, // æ°´å¹³æ¼‚ç§»
                        opacity: 1,
                        decay: 0.005 + Math.random() * 0.005 // é€æ˜åº¦è¡°å‡
                    });
                }
            });
        }

        // ç»˜åˆ¶é›ªèŠ±åŠ¨ç”»
        function drawSnowflakes() {
            snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
            
            // é•œåƒç¿»è½¬é›ªèŠ±ç”»å¸ƒä»¥åŒ¹é…
            snowCtx.scale(-1, 1);
            snowCtx.translate(-snowCanvas.width, 0);
            
            const aliveSnowflakes = [];
            
            drawingState.snowflakes.forEach(snow => {
                // æ›´æ–°ä½ç½®
                snow.y += snow.velocity;
                snow.x += snow.drift;
                snow.opacity -= snow.decay;
                
                // åªä¿ç•™å¯è§çš„é›ªèŠ±
                if (snow.opacity > 0 && snow.y < snowCanvas.height) {
                    // ç»˜åˆ¶é›ªèŠ±
                    snowCtx.beginPath();
                    snowCtx.arc(snow.x, snow.y, snow.size / 2, 0, Math.PI * 2);
                    snowCtx.fillStyle = `${snow.color}${Math.floor(snow.opacity * 255).toString(16).padStart(2, '0')}`;
                    snowCtx.fill();
                    
                    aliveSnowflakes.push(snow);
                }
            });
            
            drawingState.snowflakes = aliveSnowflakes;
            
            // æ¢å¤ç”»å¸ƒçŠ¶æ€
            snowCtx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹ï¼ˆè°ƒè¯•ç”¨ï¼‰
        function drawHandLandmarks(landmarks) {
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.lineWidth = 2;
            
            // ç»˜åˆ¶å…³èŠ‚ç‚¹
            landmarks.forEach(landmark => {
                const x = landmark.x * canvas.width;
                const y = landmark.y * canvas.height;
                
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // ç»˜åˆ¶éª¨éª¼è¿çº¿
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // æ‹‡æŒ‡
                [0, 5], [5, 6], [6, 7], [7, 8], // é£ŸæŒ‡
                [0, 9], [9, 10], [10, 11], [11, 12], // ä¸­æŒ‡
                [0, 13], [13, 14], [14, 15], [15, 16], // æ— åæŒ‡
                [0, 17], [17, 18], [18, 19], [19, 20]  // å°æŒ‡
            ];
            
            connections.forEach(([start, end]) => {
                const s = landmarks[start];
                const e = landmarks[end];
                
                ctx.beginPath();
                ctx.moveTo(s.x * canvas.width, s.y * canvas.height);
                ctx.lineTo(e.x * canvas.width, e.y * canvas.height);
                ctx.stroke();
            });
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            if (isModelLoaded && video.readyState >= 2) {
                // æŒç»­æ£€æµ‹æ‰‹éƒ¨
                hands.send({ image: video });
                
                // ç»˜åˆ¶é›ªèŠ±
                drawSnowflakes();
            }
            
            requestAnimationFrame(animate);
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MediaPipeéš”ç©ºå†™å­—</title>
    <style>
        /* åŸºç¡€æ ·å¼ */
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            overflow: hidden; /* é¿å…æ»šåŠ¨æ¡ */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #app-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #output_video {
            /* è§†é¢‘æµå’ŒCanvasé‡å  */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* ä¿æŒè§†é¢‘å†…å®¹å……æ»¡å®¹å™¨ */
            /* é•œåƒç¿»è½¬ï¼Œè®©ç”¨æˆ·æ„Ÿè§‰æ›´è‡ªç„¶ */
            transform: scaleX(-1);
        }

        #writing_canvas {
            /* ç»˜å›¾Canvasï¼Œè¦†ç›–åœ¨è§†é¢‘ä¹‹ä¸Š */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* ç¡®ä¿Canvasä¹Ÿèƒ½åƒè§†é¢‘ä¸€æ ·é•œåƒç¿»è½¬ï¼Œä½¿å†™å­—æ–¹å‘æ­£ç¡® */
            transform: scaleX(-1);
            z-index: 2;
        }

        #gesture_canvas {
            /* éª¨æ¶ç»˜åˆ¶Canvasï¼Œé€šå¸¸ç”¨è¿™ä¸ªæ¥æ˜¾ç¤ºMediaPipeçš„éª¨æ¶ */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 3;
            pointer-events: none; /* å…è®¸ç‚¹å‡»ç©¿é€åˆ°ä¸‹é¢çš„canvas */
        }
        
        /* UI é¢æ¿æ ·å¼ */
        #ui-panel {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        #ui-panel.active {
            opacity: 1;
            pointer-events: auto;
        }

        .panel-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .ui-item {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 2px solid transparent;
            font-size: 20px;
            color: white;
            transition: border-color 0.2s;
            position: relative;
        }

        .ui-item.selected {
            border-color: yellow;
            box-shadow: 0 0 8px yellow;
        }
        
        .ui-color {
            background-color: var(--color);
        }

        .ui-size-indicator {
            background-color: white;
        }
        
        .ui-size-indicator::after {
            content: '';
            display: block;
            background-color: black;
            border-radius: 50%;
            transition: width 0.3s, height 0.3s;
        }
        
        /* æç¤ºä¿¡æ¯ */
        #hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 15px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            z-index: 5;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248267/drawing_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="app-container">
        <video id="output_video" autoplay playsinline></video>

        <canvas id="writing_canvas"></canvas>

        <canvas id="gesture_canvas"></canvas>

        <div id="ui-panel">
            <div class="panel-row">
                <div class="ui-item ui-tool" id="tool-pen" data-tool="pen">ğŸ–Šï¸</div>
                <div class="ui-item ui-tool" id="tool-eraser" data-tool="eraser">ğŸ§¼</div>
            </div>
            <div class="panel-row" id="color-row">
                <div class="ui-item ui-color" style="--color: red;" data-color="red"></div>
                <div class="ui-item ui-color" style="--color: blue;" data-color="blue"></div>
                <div class="ui-item ui-color" style="--color: green;" data-color="green"></div>
                <div class="ui-item ui-color" style="--color: black;" data-color="black"></div>
            </div>
            <div class="panel-row" id="size-row">
                <div class="ui-item ui-size" data-size="5">
                    <div class="ui-size-indicator" style="width:10px; height:10px;"></div>
                </div>
                <div class="ui-item ui-size" data-size="15">
                    <div class="ui-size-indicator" style="width:20px; height:20px;"></div>
                </div>
                <div class="ui-item ui-size" data-size="30">
                    <div class="ui-size-indicator" style="width:30px; height:30px;"></div>
                </div>
            </div>
        </div>
        
        <div id="hint">
            ğŸ‘‹ **å†™å­—:** é£ŸæŒ‡+æ‹‡æŒ‡æåˆ | ğŸ“ **å·¥å…·/è®¾ç½®:** æ•´ä¸ªæ‰‹æŒæ‰“å¼€ | âœ¨ **æ¸…ç©º:** é£ŸæŒ‡+ä¸­æŒ‡å¼ å¼€
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('output_video');
        const gestureCanvas = document.getElementById('gesture_canvas');
        const gestureCtx = gestureCanvas.getContext('2d');
        const writingCanvas = document.getElementById('writing_canvas');
        const writingCtx = writingCanvas.getContext('2d');
        const uiPanel = document.getElementById('ui-panel');
        
        let isDrawing = false;
        let isSelecting = false;
        let currentTool = 'pen'; // 'pen' or 'eraser'
        let currentColor = 'black';
        let currentSize = 15;
        
        // ç”¨äºä¿å­˜æ‰€æœ‰çš„ç»˜åˆ¶è·¯å¾„ï¼ˆç”¨äºé›ªèŠ±æ¶ˆæ•£ï¼‰
        let drawingPaths = [];
        let currentPath = [];

        // ç¼©æ”¾ç›¸å…³å˜é‡
        let initialPinchDistance = 0;
        let currentScale = 1;
        let originalCanvasSize = { width: 0, height: 0 };
        
        // Canvasåˆå§‹åŒ–å’ŒResize
        function resizeCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            videoElement.width = width;
            videoElement.height = height;
            
            gestureCanvas.width = width;
            gestureCanvas.height = height;
            writingCanvas.width = width;
            writingCanvas.height = height;
            
            if (originalCanvasSize.width === 0) {
                originalCanvasSize.width = width;
                originalCanvasSize.height = height;
            }
            
            // é‡æ–°åº”ç”¨ç¼©æ”¾
            applyCanvasTransform();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Canvas ç»˜å›¾å‡½æ•° ---

        function drawLine(start, end, pathData) {
            writingCtx.beginPath();
            writingCtx.lineJoin = 'round';
            writingCtx.lineCap = 'round';

            writingCtx.lineWidth = pathData.size;
            if (pathData.tool === 'pen') {
                writingCtx.strokeStyle = pathData.color;
                writingCtx.globalCompositeOperation = 'source-over';
            } else { // eraser
                writingCtx.strokeStyle = 'rgba(0,0,0,1)'; // å®é™…æ“¦é™¤çš„æ˜¯ä¸‹é¢çš„å†…å®¹
                writingCtx.globalCompositeOperation = 'destination-out';
            }
            
            writingCtx.moveTo(start.x, start.y);
            writingCtx.lineTo(end.x, end.y);
            writingCtx.stroke();
        }
        
        // é‡ç»˜æ‰€æœ‰è·¯å¾„ (ç”¨äºç¼©æ”¾å’Œæ¸…ç©º)
        function redrawAllPaths() {
            // æ¸…ç©ºä¸»ç»˜å›¾å±‚
            writingCtx.clearRect(0, 0, writingCanvas.width, writingCanvas.height);
            
            // åº”ç”¨ç¼©æ”¾
            applyCanvasTransform();
            
            drawingPaths.forEach(path => {
                // ç»˜åˆ¶å½“å‰è·¯å¾„çš„æ¯ä¸€æ®µ
                for (let i = 1; i < path.points.length; i++) {
                    drawLine(path.points[i - 1], path.points[i], path);
                }
            });
        }
        
        // åº”ç”¨Canvaså˜æ¢ï¼ˆç¼©æ”¾ï¼‰
        function applyCanvasTransform() {
            writingCtx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®å˜æ¢
            
            // é•œåƒç¿»è½¬
            writingCtx.translate(writingCanvas.width, 0);
            writingCtx.scale(-1, 1);
            
            // ç¼©æ”¾
            const scale = currentScale;
            const centerX = writingCanvas.width / 2;
            const centerY = writingCanvas.height / 2;

            writingCtx.translate(centerX, centerY);
            writingCtx.scale(scale, scale);
            writingCtx.translate(-centerX, -centerY);
        }


        // --- MediaPipe åˆå§‹åŒ– ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // è·å–æ‘„åƒå¤´æƒé™å¹¶å¯åŠ¨ MediaPipe
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = resolve;
                });
                videoElement.play();
                
                // å¼€å§‹ MediaPipe å¾ªç¯
                sendToMediaPipe();
            } catch (error) {
                console.error("æ— æ³•è®¿é—®æ‘„åƒå¤´:", error);
                document.getElementById('hint').textContent = "é”™è¯¯: æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚";
            }
        }

        async function sendToMediaPipe() {
            if (!videoElement.paused && !videoElement.ended) {
                await hands.send({image: videoElement});
            }
            requestAnimationFrame(sendToMediaPipe);
        }
        
        // --- æ‰‹åŠ¿è¯†åˆ«è¾…åŠ©å‡½æ•° ---

        // è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // æ£€æŸ¥æåˆæ‰‹åŠ¿ï¼ˆé£ŸæŒ‡å’Œæ‹‡æŒ‡ï¼‰
        function isPinched(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = getDistance(thumbTip, indexTip);
            // é£ŸæŒ‡å’Œæ‹‡æŒ‡æåˆè·ç¦»é˜ˆå€¼ (å½’ä¸€åŒ–åæ ‡)
            const threshold = 0.05; 
            return distance < threshold;
        }
        
        // æ£€æŸ¥æ‰‹æŒæ˜¯å¦å¼ å¼€ (æ‰€æœ‰æ‰‹æŒ‡)
        function isPalmOpen(landmarks) {
            // æ£€æŸ¥æ¯ä¸ªæŒ‡å°–åˆ°å¯¹åº”æŒ‡æ ¹çš„å‚ç›´è·ç¦»
            // index_finger_tip(8) - index_finger_pip(6)
            // middle_finger_tip(12) - middle_finger_pip(10)
            // ring_finger_tip(16) - ring_finger_pip(14)
            // pinky_tip(20) - pinky_pip(18)
            const fingerTips = [8, 12, 16, 20];
            const fingerPips = [6, 10, 14, 18];
            const wrist = landmarks[0];
            
            // ç®€å•çš„æ£€æŸ¥ï¼šæ‰€æœ‰æŒ‡å°–ä¸æ‰‹è…•çš„è·ç¦»æ˜¯å¦éƒ½å¤§äºæŸä¸ªé˜ˆå€¼ï¼ˆè¡¨ç¤ºå¼ å¼€ï¼‰
            const threshold = 0.25; 
            
            return fingerTips.every(index => getDistance(landmarks[index], wrist) > threshold);
        }

        // æ£€æŸ¥é£ŸæŒ‡å’Œä¸­æŒ‡å¼ å¼€ï¼ˆæ¸…ç©ºæ‰‹åŠ¿ï¼‰
        function isScissors(landmarks) {
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            
            // é£ŸæŒ‡å’Œä¸­æŒ‡è·ç¦»è¾ƒå¤§ï¼Œä¸”å…¶ä»–æ‰‹æŒ‡é è¿‘
            const openDistance = getDistance(indexTip, middleTip);
            const closedDistanceRing = getDistance(middleTip, ringTip);
            const closedDistancePinky = getDistance(ringTip, pinkyTip);

            // å½’ä¸€åŒ–åæ ‡é˜ˆå€¼
            const openThreshold = 0.1;
            const closedThreshold = 0.07;
            
            return openDistance > openThreshold && 
                   closedDistanceRing < closedThreshold && 
                   closedDistancePinky < closedThreshold;
        }
        
        // --- é›ªèŠ±æ¶ˆæ•£æ•ˆæœ ---
        
        let particles = [];
        const PARTICLE_COUNT = 300; // æ¯æ¸…ç©ºä¸€æ¬¡ç”Ÿæˆçš„ç²’å­æ•°
        
        // å°† Canvas ä¸Šçš„åƒç´ è½¬æ¢ä¸ºç²’å­
        function createParticles() {
            const imageData = writingCtx.getImageData(0, 0, writingCanvas.width, writingCanvas.height);
            const data = imageData.data;
            particles = [];
            
            const step = Math.ceil( (writingCanvas.width * writingCanvas.height) / PARTICLE_COUNT);

            for (let i = 0; i < data.length; i += 4 * step) {
                const x = (i / 4) % writingCanvas.width;
                const y = Math.floor((i / 4) / writingCanvas.width);
                const alpha = data[i + 3];
                
                if (alpha > 0) { // åªå¤„ç†éé€æ˜åƒç´ 
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 0.5, // åˆå§‹é€Ÿåº¦
                        vy: Math.random() * -1 - 1,
                        color: `rgb(${r},${g},${b})`,
                        size: Math.random() * 2 + 1,
                        alpha: 1,
                        gravity: 0.05
                    });
                }
            }
            
            // æ¸…ç©ºç»˜å›¾å†…å®¹
            drawingPaths = [];
            writingCtx.clearRect(0, 0, writingCanvas.width, writingCanvas.height);
        }
        
        // æ¸²æŸ“å’Œæ›´æ–°ç²’å­
        function updateAndDrawParticles() {
            // åªæ¸…ç©ºä¸é‡ç»˜ï¼Œè®©é›ªèŠ±å¯ä»¥é£˜è½
            // writingCtx.clearRect(0, 0, writingCanvas.width, writingCanvas.height); 
            
            // è®¾ç½®ä¸€ä¸ªåŠé€æ˜èƒŒæ™¯ï¼Œåˆ›å»ºæ‹–å°¾æ•ˆæœ
            writingCtx.fillStyle = 'rgba(255, 255, 255, 0.1)'; 
            writingCtx.fillRect(0, 0, writingCanvas.width, writingCanvas.height);

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                // æ›´æ–°ä½ç½®å’Œé€Ÿåº¦ (æ¨¡æ‹Ÿé£˜è½)
                p.x += p.vx;
                p.y += p.vy;
                p.vy += p.gravity; // å‘ä¸‹çš„é‡åŠ›
                p.alpha -= 0.005; // é€æ¸æ¶ˆå¤±
                
                // æ¸²æŸ“ç²’å­
                writingCtx.fillStyle = p.color;
                writingCtx.globalAlpha = p.alpha;
                writingCtx.beginPath();
                // æ³¨æ„ï¼šè¿™é‡Œç²’å­æ²¡æœ‰é•œåƒç¿»è½¬ï¼Œå› ä¸ºå®ƒä»¬æ˜¯åœ¨é•œåƒç¿»è½¬åçš„Canvasä¸Šç»˜åˆ¶çš„
                writingCtx.arc(writingCanvas.width - p.x, p.y, p.size, 0, Math.PI * 2);
                writingCtx.fill();
                
                // ç§»é™¤æ¶ˆå¤±çš„ç²’å­
                if (p.alpha <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            writingCtx.globalAlpha = 1; // é‡ç½®é€æ˜åº¦
            writingCtx.globalCompositeOperation = 'source-over'; // é‡ç½®æ··åˆæ¨¡å¼

            if (particles.length > 0) {
                requestAnimationFrame(updateAndDrawParticles);
            }
        }

        // --- UI é¢æ¿æ§åˆ¶ ---

        function updateUISelection() {
            // æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.ui-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // é€‰ä¸­å½“å‰å·¥å…·
            document.getElementById(`tool-${currentTool}`).classList.add('selected');
            
            // é€‰ä¸­å½“å‰é¢œè‰²
            document.querySelector(`[data-color="${currentColor}"]`).classList.add('selected');
            
            // é€‰ä¸­å½“å‰å¤§å°
            const sizeItem = document.querySelector(`[data-size="${currentSize}"]`);
            if (sizeItem) {
                sizeItem.classList.add('selected');
            }
        }
        
        function selectUIItem(normalizedX, normalizedY) {
            // å½’ä¸€åŒ–åæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
            const x = normalizedX * writingCanvas.width;
            const y = normalizedY * writingCanvas.height;
            
            let selectedItem = null;

            // æ£€æŸ¥æ˜¯å¦å‡»ä¸­äº†ä»»ä½• UI å…ƒç´ 
            document.querySelectorAll('.ui-item').forEach(item => {
                const rect = item.getBoundingClientRect();
                
                // æ³¨æ„ï¼šUIé¢æ¿æ²¡æœ‰é•œåƒç¿»è½¬ï¼Œæ‰€ä»¥ç›´æ¥ä½¿ç”¨clientX/Y
                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    selectedItem = item;
                }
            });
            
            if (selectedItem) {
                const tool = selectedItem.getAttribute('data-tool');
                const color = selectedItem.getAttribute('data-color');
                const size = selectedItem.getAttribute('data-size');
                
                if (tool) {
                    currentTool = tool;
                } else if (color) {
                    currentColor = color;
                } else if (size) {
                    currentSize = parseInt(size);
                }
                
                updateUISelection();
                // é€‰é¡¹è¢«é€‰ä¸­åï¼Œå¯ä»¥è‡ªåŠ¨å…³é—­é¢æ¿
                isSelecting = false;
                uiPanel.classList.remove('active');
            }
        }

        // --- MediaPipe ç»“æœå¤„ç†å‡½æ•° ---

        function onResults(results) {
            gestureCtx.save();
            gestureCtx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height);

            const allLandmarks = results.multiHandLandmarks;

            if (allLandmarks && allLandmarks.length > 0) {
                // ç»˜åˆ¶éª¨æ¶
                for (const landmarks of allLandmarks) {
                    drawConnectors(gestureCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 5});
                    drawLandmarks(gestureCtx, landmarks, {color: '#FF0000', lineWidth: 2});
                }

                // **Step 1: å¤„ç† UI é¢æ¿**
                const primaryHandLandmarks = allLandmarks[0]; // æ€»æ˜¯æ£€æµ‹ç¬¬ä¸€åªæ‰‹

                if (isPalmOpen(primaryHandLandmarks)) {
                    // æ•´ä¸ªæ‰‹æŒæ‰“å¼€ -> å¼¹å‡ºUIé¢æ¿
                    if (!isSelecting && !isDrawing) {
                         isSelecting = true;
                         uiPanel.classList.add('active');
                         updateUISelection();
                    }
                    
                    // é¢æ¿å¼¹å‡ºæ—¶ï¼Œç”¨é£ŸæŒ‡å°–è¿›è¡Œé€‰æ‹© (ç‚¹ä½ 8)
                    if (isSelecting) {
                        // é•œåƒç¿»è½¬åçš„ Canvas åæ ‡
                        const tip = primaryHandLandmarks[8]; 
                        // **æ³¨æ„ï¼šè¿™é‡Œéœ€è¦å°† MediaPipe çš„å½’ä¸€åŒ–åæ ‡è½¬æ¢ä¸ºéé•œåƒçš„å±å¹•åæ ‡**
                        selectUIItem(1 - tip.x, tip.y); 
                    }
                } else if (isSelecting) {
                    // æ‰‹æŒåˆæ‹¢æˆ–è¿›è¡Œå…¶ä»–åŠ¨ä½œæ—¶ï¼Œéšè—é¢æ¿
                    // è¿™é‡Œç®€åŒ–é€»è¾‘ï¼šå½“UIé¢æ¿æ‰“å¼€æ—¶ï¼Œåªæœ‰é£ŸæŒ‡ç‚¹é€‰æœ‰æ•ˆã€‚
                    // ä¸ºäº†é˜²æ­¢è¯¯è§¦ï¼Œæˆ‘ä»¬è®©å®ƒä¿æŒå¼€å¯ï¼Œç›´åˆ°é€‰æ‹©å®Œã€‚
                    // å®é™…æ“ä½œä¸­ï¼Œå¯ä»¥è®¾ç½®ä¸€ä¸ªå»¶æ—¶æˆ–æ›´å¤æ‚çš„é€€å‡ºæ‰‹åŠ¿ã€‚
                    // è¿™é‡Œæˆ‘ä»¬å‡è®¾é€‰æ‹©å®Œåè‡ªåŠ¨é€€å‡º (åœ¨ selectUIItem ä¸­å®ç°)ã€‚
                } else {
                    uiPanel.classList.remove('active');
                }
                
                // **Step 2: å¤„ç†é›ªèŠ±æ¶ˆæ•£/æ¸…ç©º**
                if (isScissors(primaryHandLandmarks) && !isSelecting && particles.length === 0) {
                    if (drawingPaths.length > 0) {
                        createParticles(); // åˆ›å»ºç²’å­
                        requestAnimationFrame(updateAndDrawParticles); // å¯åŠ¨åŠ¨ç”»
                    }
                }

                // **Step 3: å¤„ç†å†™å­—/æåˆ**
                if (!isSelecting) {
                    const isPinchedState = isPinched(primaryHandLandmarks);
                    const tip = primaryHandLandmarks[8]; // é£ŸæŒ‡å°–
                    
                    // å°† MediaPipe çš„å½’ä¸€åŒ–åæ ‡è½¬æ¢ä¸º Canvas åƒç´ åæ ‡
                    // å› ä¸º Canvas æœ¬èº«è¢« transform: scaleX(-1) ç¿»è½¬ï¼Œæ‰€ä»¥ç›´æ¥ä½¿ç”¨ x åæ ‡
                    const x = tip.x * writingCanvas.width; 
                    const y = tip.y * writingCanvas.height;

                    if (isPinchedState) {
                        if (!isDrawing) {
                            // å¼€å§‹ç»˜åˆ¶
                            isDrawing = true;
                            
                            // åˆ›å»ºæ–°çš„è·¯å¾„
                            const newPath = {
                                color: currentColor,
                                size: currentSize,
                                tool: currentTool,
                                points: []
                            };
                            drawingPaths.push(newPath);
                            currentPath = newPath.points;

                            // è®°å½•èµ·å§‹ç‚¹
                            currentPath.push({x: x, y: y});
                        } else {
                            // æ­£åœ¨ç»˜åˆ¶
                            const lastPoint = currentPath[currentPath.length - 1];
                            const newPoint = {x: x, y: y};
                            
                            // ç»˜åˆ¶å½“å‰çº¿æ®µ
                            drawLine(lastPoint, newPoint, drawingPaths[drawingPaths.length - 1]);
                            
                            // è®°å½•æ–°ç‚¹
                            currentPath.push(newPoint);
                        }
                    } else {
                        isDrawing = false;
                        currentPath = [];
                    }
                }
                
                // **Step 4: å¤„ç†ç¼©æ”¾ (ä¸¤åªæ‰‹)**
                if (allLandmarks.length === 2 && !isDrawing && !isSelecting) {
                    const hand1 = allLandmarks[0];
                    const hand2 = allLandmarks[1];
                    
                    const p1 = hand1[8]; // æ‰‹1 é£ŸæŒ‡å°–
                    const p2 = hand2[8]; // æ‰‹2 é£ŸæŒ‡å°–

                    const currentPinchDistance = getDistance(p1, p2);

                    if (initialPinchDistance === 0) {
                        // é¦–æ¬¡æ£€æµ‹åˆ°ä¸¤æ‰‹ï¼Œè®°å½•åˆå§‹è·ç¦»
                        initialPinchDistance = currentPinchDistance;
                    } else {
                        // è®¡ç®—ç¼©æ”¾å› å­
                        const scaleFactor = currentPinchDistance / initialPinchDistance;
                        // é™åˆ¶ç¼©æ”¾èŒƒå›´
                        const newScale = Math.max(0.5, Math.min(3.0, currentScale * scaleFactor));

                        // åªæœ‰å½“å˜åŒ–æ˜¾è‘—æ—¶æ‰åº”ç”¨ç¼©æ”¾
                        if (Math.abs(newScale - currentScale) > 0.05) {
                            currentScale = newScale;
                            initialPinchDistance = currentPinchDistance; // æ›´æ–°åŸºå‡†è·ç¦»
                            redrawAllPaths(); // é‡æ–°ç»˜åˆ¶æ‰€æœ‰å†…å®¹
                        }
                    }
                } else if (allLandmarks.length < 2) {
                    // åªæœ‰ä¸€åªæ‰‹æˆ–æ²¡æœ‰æ‰‹ï¼Œé‡ç½®ç¼©æ”¾çŠ¶æ€
                    initialPinchDistance = 0;
                }
                
            } else {
                // æ²¡æœ‰æ‰‹éƒ¨æ£€æµ‹
                isDrawing = false;
                isSelecting = false;
                initialPinchDistance = 0;
                uiPanel.classList.remove('active');
            }

            gestureCtx.restore();
        }

        // å¯åŠ¨åº”ç”¨
        startCamera();

    </script>
</body>
</html>
